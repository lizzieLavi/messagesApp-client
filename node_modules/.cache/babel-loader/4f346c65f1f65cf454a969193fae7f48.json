{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\User\\\\OneDrive\\\\Desktop\\\\whatsapp\\\\myclient\\\\src\\\\contexts\\\\conversationsprovider.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useContext, useCallback, useRef } from \"react\";\nimport { useState, useEffect } from \"react\";\nimport { useUser } from \"./userprovider\";\nimport { useSocket } from \"./socketprovider\";\nimport axios from \"axios\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ConversationsContext = /*#__PURE__*/React.createContext();\nexport function useConversations() {\n  _s();\n\n  return useContext(ConversationsContext);\n}\n\n_s(useConversations, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport function ConversationsProvider({\n  children\n}) {\n  _s2();\n\n  const {\n    contacts,\n    info\n  } = useUser();\n  const [conversations, setConversations] = useState([]);\n  const [selectedConversation, setSelectedConversation] = useState();\n  const RefConversations = useRef(conversations);\n  const currentConversationRef = useRef(selectedConversation);\n  const {\n    socket,\n    ConnectedUsers\n  } = useSocket();\n  const [typingFlag, setTypingFlag] = useState(\"\");\n  const [currentConversationIsConnected, setCurrentConversationIsConnected] = useState(\"\");\n  const config = {\n    headers: {\n      \"x-access-token\": sessionStorage[\"config\"]\n    }\n  };\n  const [showDetails, setShowDetails] = useState(false);\n  const [removedFromGroupFlag, setRemovedFromGroupFlag] = useState(false);\n  const audio = new Audio(\"https://res.cloudinary.com/dsrgpqnyv/video/upload/v1630680168/juntos-607_qsfc7i.mp3\");\n  const [renderFlag, setRenderFlag] = useState(true);\n\n  const updateFunction = () => {\n    setRenderFlag(true);\n  };\n\n  useEffect(() => {\n    async function fetchData() {\n      if (socket.current == null) return; //when other user updates conversation information, update this user on changes\n\n      socket.current.on(\"update-conversation\", updateFunction); //when user was removed, remove this user from conversation\n\n      socket.current.on(\"removed-user\", async () => {\n        getConversations().then(res => {\n          setConversations(res);\n\n          if (selectedConversation) {\n            /*if this selected conversation dosn't exists in conversations anymore, this is the deleted user, \r\n            let him know he was deleted and remove this chat from selected conversation*/\n            let checkIfDeleted = res.filter(conversation => conversation._id === selectedConversation._id);\n            if (checkIfDeleted.length === 0) setRemovedFromGroupFlag(true);\n          }\n        });\n      });\n      return () => {\n        socket.current.off(\"update-conversation\", updateFunction);\n        socket.current.off(\"remove-conversation\");\n      };\n    }\n\n    fetchData();\n  }, [conversations]);\n  /*everytime a user is connected/dissconnected/ this user entered new conversation,\r\n  check if the current conversation user is connected or not*/\n\n  useEffect(() => {\n    async function fetchData() {\n      if (selectedConversation) {\n        if (!selectedConversation.isGroup) {\n          if (ConnectedUsers.some(user => user.userId === selectedConversation.Participants[0].id)) {\n            setCurrentConversationIsConnected(\"\");\n          } else {\n            let response = await axios.get(\"https://messagesapp1.herokuapp.com/api/logIn/\" + selectedConversation.Participants[0].id, config);\n            setCurrentConversationIsConnected(response.data.LastSeen);\n          }\n        }\n      }\n    }\n\n    fetchData();\n  }, [ConnectedUsers, selectedConversation]); //on first render,and every time conversation updates, get new conversations from DB\n\n  useEffect(() => {\n    async function fetchData() {\n      getConversations().then(res => setConversations(res));\n    }\n\n    if (renderFlag) {\n      fetchData();\n      setRenderFlag(false);\n    }\n  }, [renderFlag]); //when other user is typing, and this user is on this conversation, let him know other user is typing\n\n  useEffect(() => {\n    if (socket.current == null) return;\n    socket.current.on(\"user-typing\", ({\n      user,\n      conversationId\n    }) => {\n      if (selectedConversation) {\n        if (selectedConversation._id === conversationId) {\n          setTypingFlag(user.name);\n        }\n      }\n    });\n  }, [selectedConversation]); //get updated conversations from DB when needed\n\n  async function getConversations() {\n    try {\n      let response = await axios.get(\"https://messagesapp1.herokuapp.com/api/conversations/UserConversations/\" + sessionStorage[\"id\"], config);\n      let ConversationsList = response.data.map(conversation => {\n        let UpdatedConversation = conversation;\n        /*if this is a private conversation, and the name and picture saved as this user name, \r\n        update the conversation to other user name and picture*/\n\n        if (!conversation.isGroup && conversation.Name === sessionStorage[\"name\"]) UpdatedConversation = { ...UpdatedConversation,\n          Name: conversation.Participants[0].name,\n          ConversationImage: conversation.Participants[0].imageName\n        }; //update the current shown on screen conversation\n\n        if (selectedConversation) {\n          if (selectedConversation._id === UpdatedConversation._id) setSelectedConversation(UpdatedConversation);\n        }\n\n        return UpdatedConversation;\n      });\n      return ConversationsList;\n    } catch (err) {\n      console.log(err);\n    }\n  } //on search event, update shown conversations list\n\n\n  async function getSearchConverastions(str) {\n    getConversations().then(res => {\n      let SearchResult = res.filter(conversation => conversation.Name.includes(str) === true);\n      setConversations(SearchResult);\n    });\n  } //create new conversation\n\n\n  async function createConversation(ids, name, image, groupFlag) {\n    let ConversationImage = image;\n    let isGroup = groupFlag;\n    let messages = [];\n    let lastMessage = \"\"; //no participants chosen\n\n    if (ids.length === 0) {\n      return {\n        status: \"error\",\n        message: \"no participants choosen\"\n      };\n    } //check if conversation already exists and it's not a group.\n\n\n    let ConversationExists = null;\n\n    if (ids.length === 1 && !isGroup) {\n      ConversationExists = conversations.find(conversation => conversation.Name === name);\n    } //if already exists, show the existing one\n\n\n    if (ConversationExists) setSelectedConversation(ConversationExists); //create new conversation\n    else {\n      //get conversation participants\n      const participants = ids.map(id => {\n        let addContactToConversation = contacts.filter(contact => id === contact.id);\n        return addContactToConversation[0];\n      }); //add creator to participants\n\n      participants.push({\n        id: info.id,\n        name: info.name,\n        phone: info.phone,\n        imageName: info.imageName,\n        LastSeen: info.LastSeen\n      });\n      let createdDate = \"\"; //if group add creation date,add creation message and upload group picture\n\n      if (isGroup) {\n        let parts = new Intl.DateTimeFormat(\"en\", {\n          hc: \"h12\",\n          year: \"numeric\",\n          month: \"2-digit\",\n          day: \"2-digit\",\n          hour: \"numeric\",\n          minute: \"numeric\",\n          timeZone: \"Asia/Jerusalem\"\n        }).formatToParts(new Date()).reduce((acc, part) => {\n          acc[part.type] = part.value;\n          return acc;\n        }, Object.create(null));\n        createdDate = `${parts.day}/${parts.month}/${parts.year} ${parts.hour}:${parts.minute}`;\n        lastMessage = {\n          name: \"manager\",\n          message: info.name + \" created this group\",\n          timeSent: \"\",\n          containsImage: false,\n          containsRecord: false,\n          recordURL: null\n        };\n        messages.push(lastMessage);\n        const data = new FormData();\n        data.append(\"file\", ConversationImage);\n        data.append(\"upload_preset\", \"whatsApp_clone\");\n        data.append(\"cloud_name\", \"dsrgpqnyv\");\n\n        try {\n          let response = await axios.post(\"https://api.cloudinary.com/v1_1/dsrgpqnyv/image/upload\", data);\n          ConversationImage = response.data.url;\n        } catch (err) {\n          console.log(err);\n        }\n      }\n\n      let newConversation = {\n        Name: name,\n        creatorId: sessionStorage[\"id\"],\n        Participants: participants,\n        Messages: messages,\n        LastMessage: lastMessage,\n        ConversationImage: ConversationImage,\n        isGroup: isGroup,\n        createdDate: createdDate,\n        description: \"Add Description\"\n      }; //updateDB\n\n      try {\n        let Response = await axios.post(\"https://messagesapp1.herokuapp.com/api/conversations\", newConversation, config);\n\n        if (Response.data.status === \"created\") {\n          setSelectedConversation(Response.data.conversation); //show conversation only if messages sent or if its A group\n\n          if (Response.data.conversation.Messages.length > 0 || Response.data.conversation.isGroup === true) {\n            setConversations(prevConversations => {\n              return [...prevConversations, Response.data.conversation];\n            });\n            socket.current.emit(\"conversation-changed\", Response.data.conversation);\n          }\n        }\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  } //update existing conversation details when changed\n\n\n  async function UpdateConversation(updatedConversation) {\n    let updateDBConv = { ...updatedConversation\n    }; //if user left the group, dont add him to DB\n\n    if (!updatedConversation.LastMessage.message.includes(\"left\")) {\n      let addCurrentParticipant = {\n        id: info.id,\n        phone: info.phone,\n        name: info.name,\n        imageName: info.imageName,\n        Status: info.Status,\n        color: info.color\n      };\n      let participants = [...updatedConversation.Participants, addCurrentParticipant];\n      updateDBConv = { ...updateDBConv,\n        Participants: participants\n      };\n    }\n\n    delete updateDBConv._id;\n\n    try {\n      let response = await axios.put(\"https://messagesapp1.herokuapp.com/api/conversations/\" + selectedConversation._id, updateDBConv, config);\n\n      if (response.data.status === \"Updated\") {\n        let UpdatedConversations = [];\n\n        if (!updatedConversation.LastMessage.message.includes(\"left\")) {\n          setSelectedConversation(updatedConversation);\n          conversations.forEach(conversation => {\n            if (conversation._id === updatedConversation._id) UpdatedConversations.push(updatedConversation);else UpdatedConversations.push(conversation);\n          });\n        } else {\n          UpdatedConversations = conversations.filter(conversation => conversation._id !== selectedConversation._id);\n          setSelectedConversation();\n        } //if user where removed by admin, send to user deleted case, so server let him know he was deleted\n\n\n        if (updatedConversation.LastMessage.message.includes(\"removed\")) socket.current.emit(\"user-deleted\", selectedConversation);else socket.current.emit(\"conversation-changed\", selectedConversation);\n        setConversations(UpdatedConversations);\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  function updateConversationParticipant(userUpdatedInfo, infoFlag, information) {\n    let updateConv = [];\n    conversations.map(async conversation => {\n      let updateCon = \"\";\n\n      if (conversation.Name === userUpdatedInfo.info && conversation.isGroup == false) {\n        if (infoFlag === \"name\") {\n          updateCon = { ...conversation,\n            Name: information\n          };\n        } else if (infoFlag == \"image\") updateCon = { ...conversation,\n          ConversationImage: information\n        };\n      } else updateCon = { ...conversation\n      };\n\n      updateConv.push(updateCon);\n      let newParticipants = [...conversation.Participants, userUpdatedInfo];\n      let tempCon = { ...updateCon,\n        Participants: newParticipants\n      };\n      delete tempCon._id;\n\n      try {\n        await axios.put(\"https://messagesapp1.herokuapp.com/api/conversations/\" + conversation._id, tempCon, config);\n      } catch (err) {\n        console.log(err);\n      }\n\n      socket.current.emit(\"conversation-changed\", updateCon);\n      setConversations(updateConv);\n    });\n  } //add message got from other user to conversation\n\n\n  const addMessageToConversation = useCallback(async ({\n    UpdatedConv\n  }) => {\n    //voice alert\n    audio.play();\n    let ConversationExists = false; //use refConversations to void infinite loop\n\n    let newListOfConversations = RefConversations.current.map(conversation => {\n      if (conversation._id === UpdatedConv._id) {\n        ConversationExists = true;\n        let newConv = { ...conversation,\n          Messages: UpdatedConv.Messages,\n          LastMessage: UpdatedConv.LastMessage\n        };\n\n        if (currentConversationRef.current) {\n          if (currentConversationRef.current._id === UpdatedConv._id) setSelectedConversation(newConv);\n        }\n\n        return newConv;\n      } else return conversation;\n    }); // if this is a new conversation first message, update user conversations\n\n    if (!ConversationExists) {\n      if (!UpdatedConv.isGroup) {\n        let newConversation = { ...UpdatedConv,\n          Name: UpdatedConv.Participants[0].name,\n          ConversationImage: UpdatedConv.Participants[0].imageName\n        };\n        setConversations(prevConversations => [...prevConversations, newConversation]);\n      } else setConversations(prevConversations => [...prevConversations, UpdatedConv]);\n    } else setConversations(newListOfConversations);\n  }, [setConversations]); //handle messages socket\n\n  useEffect(() => {\n    if (socket.current == null) return;\n    RefConversations.current = conversations;\n    currentConversationRef.current = selectedConversation;\n    socket.current.on(\"receive-message\", addMessageToConversation);\n    return () => socket.current.off(\"receive-message\", addMessageToConversation);\n  }, [conversations, selectedConversation]); //update the message sender conversations\n\n  const updateSenderConversation = AddMessage => {\n    let ConversationExists = false;\n    setSelectedConversation(AddMessage);\n    let newListOfConcversations = conversations.map(conversation => {\n      if (conversation._id === AddMessage._id) {\n        ConversationExists = true;\n        return AddMessage;\n      } else return conversation;\n    });\n\n    if (ConversationExists) {\n      setConversations(newListOfConcversations);\n    } else setConversations(prevConversations => [...prevConversations, AddMessage]);\n  }; //send new message to chat users\n\n\n  function sendMessage(text, imageFlag, imageURL, recordURL) {\n    let parts = new Intl.DateTimeFormat(\"en\", {\n      hc: \"h12\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"numeric\",\n      minute: \"numeric\",\n      timeZone: \"Asia/Jerusalem\"\n    }).formatToParts(new Date()).reduce((acc, part) => {\n      acc[part.type] = part.value;\n      return acc;\n    }, Object.create(null));\n    let time = `${parts.day}/${parts.month}/${parts.year}  ${parts.hour}:${parts.minute}`;\n    let recordFlag = false;\n    if (recordURL != null) recordFlag = true;\n    let CurrentMessage = {\n      id: info.id,\n      name: info.name,\n      color: info.color,\n      message: text,\n      timeSent: time,\n      containsImage: imageFlag,\n      containsRecord: recordFlag,\n      recordURL: recordURL\n    };\n    if (imageFlag === true) CurrentMessage = { ...CurrentMessage,\n      imageURL: imageURL\n    };\n    let sender = {\n      id: info.id,\n      phone: info.phone,\n      name: info.name,\n      imageName: info.imageName\n    };\n    let AddMessage = { ...selectedConversation,\n      Messages: [...selectedConversation.Messages, CurrentMessage],\n      LastMessage: CurrentMessage\n    };\n    socket.current.emit(\"send-message\", {\n      sender: sender,\n      UpdatedConversation: AddMessage,\n      conversationId: selectedConversation._id\n    });\n    updateSenderConversation(AddMessage);\n  }\n\n  return /*#__PURE__*/_jsxDEV(ConversationsContext.Provider, {\n    value: {\n      sendMessage,\n      conversations,\n      createConversation,\n      setConversations,\n      setSelectedConversation,\n      selectedConversation,\n      currentConversationIsConnected,\n      typingFlag,\n      setTypingFlag,\n      getSearchConverastions,\n      showDetails,\n      setShowDetails,\n      UpdateConversation,\n      removedFromGroupFlag,\n      setRemovedFromGroupFlag,\n      updateConversationParticipant\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 535,\n    columnNumber: 5\n  }, this);\n}\n\n_s2(ConversationsProvider, \"zn3mbHqj3R/86k8dj5q/1FSwOmY=\", false, function () {\n  return [useUser, useSocket];\n});\n\n_c = ConversationsProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"ConversationsProvider\");","map":{"version":3,"sources":["C:/Users/User/OneDrive/Desktop/whatsapp/myclient/src/contexts/conversationsprovider.js"],"names":["React","useContext","useCallback","useRef","useState","useEffect","useUser","useSocket","axios","ConversationsContext","createContext","useConversations","ConversationsProvider","children","contacts","info","conversations","setConversations","selectedConversation","setSelectedConversation","RefConversations","currentConversationRef","socket","ConnectedUsers","typingFlag","setTypingFlag","currentConversationIsConnected","setCurrentConversationIsConnected","config","headers","sessionStorage","showDetails","setShowDetails","removedFromGroupFlag","setRemovedFromGroupFlag","audio","Audio","renderFlag","setRenderFlag","updateFunction","fetchData","current","on","getConversations","then","res","checkIfDeleted","filter","conversation","_id","length","off","isGroup","some","user","userId","Participants","id","response","get","data","LastSeen","conversationId","name","ConversationsList","map","UpdatedConversation","Name","ConversationImage","imageName","err","console","log","getSearchConverastions","str","SearchResult","includes","createConversation","ids","image","groupFlag","messages","lastMessage","status","message","ConversationExists","find","participants","addContactToConversation","contact","push","phone","createdDate","parts","Intl","DateTimeFormat","hc","year","month","day","hour","minute","timeZone","formatToParts","Date","reduce","acc","part","type","value","Object","create","timeSent","containsImage","containsRecord","recordURL","FormData","append","post","url","newConversation","creatorId","Messages","LastMessage","description","Response","prevConversations","emit","UpdateConversation","updatedConversation","updateDBConv","addCurrentParticipant","Status","color","put","UpdatedConversations","forEach","updateConversationParticipant","userUpdatedInfo","infoFlag","information","updateConv","updateCon","newParticipants","tempCon","addMessageToConversation","UpdatedConv","play","newListOfConversations","newConv","updateSenderConversation","AddMessage","newListOfConcversations","sendMessage","text","imageFlag","imageURL","time","recordFlag","CurrentMessage","sender"],"mappings":"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","sourcesContent":["import React, { useContext, useCallback, useRef } from \"react\";\r\nimport { useState, useEffect } from \"react\";\r\nimport { useUser } from \"./userprovider\";\r\nimport { useSocket } from \"./socketprovider\";\r\nimport axios from \"axios\";\r\n\r\nconst ConversationsContext = React.createContext();\r\n\r\nexport function useConversations() {\r\n  return useContext(ConversationsContext);\r\n}\r\n\r\nexport function ConversationsProvider({ children }) {\r\n  const { contacts, info } = useUser();\r\n  const [conversations, setConversations] = useState([]);\r\n  const [selectedConversation, setSelectedConversation] = useState();\r\n  const RefConversations = useRef(conversations);\r\n  const currentConversationRef = useRef(selectedConversation);\r\n  const { socket, ConnectedUsers } = useSocket();\r\n  const [typingFlag, setTypingFlag] = useState(\"\");\r\n  const [currentConversationIsConnected, setCurrentConversationIsConnected] =\r\n    useState(\"\");\r\n  const config = { headers: { \"x-access-token\": sessionStorage[\"config\"] } };\r\n  const [showDetails, setShowDetails] = useState(false);\r\n  const [removedFromGroupFlag, setRemovedFromGroupFlag] = useState(false);\r\n  const audio = new Audio(\r\n    \"https://res.cloudinary.com/dsrgpqnyv/video/upload/v1630680168/juntos-607_qsfc7i.mp3\"\r\n  );\r\n  const [renderFlag, setRenderFlag] = useState(true);\r\n\r\n  const updateFunction = () => {\r\n    setRenderFlag(true);\r\n  };\r\n\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      if (socket.current == null) return;\r\n      //when other user updates conversation information, update this user on changes\r\n      socket.current.on(\"update-conversation\", updateFunction);\r\n\r\n      //when user was removed, remove this user from conversation\r\n      socket.current.on(\"removed-user\", async () => {\r\n        getConversations().then((res) => {\r\n          setConversations(res);\r\n          if (selectedConversation) {\r\n            /*if this selected conversation dosn't exists in conversations anymore, this is the deleted user, \r\n          let him know he was deleted and remove this chat from selected conversation*/\r\n            let checkIfDeleted = res.filter(\r\n              (conversation) => conversation._id === selectedConversation._id\r\n            );\r\n            if (checkIfDeleted.length === 0) setRemovedFromGroupFlag(true);\r\n          }\r\n        });\r\n      });\r\n      return () => {\r\n        socket.current.off(\"update-conversation\", updateFunction);\r\n        socket.current.off(\"remove-conversation\");\r\n      };\r\n    }\r\n\r\n    fetchData();\r\n  }, [conversations]);\r\n\r\n  /*everytime a user is connected/dissconnected/ this user entered new conversation,\r\n check if the current conversation user is connected or not*/\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      if (selectedConversation) {\r\n        if (!selectedConversation.isGroup) {\r\n          if (\r\n            ConnectedUsers.some(\r\n              (user) => user.userId === selectedConversation.Participants[0].id\r\n            )\r\n          ) {\r\n            setCurrentConversationIsConnected(\"\");\r\n          } else {\r\n            let response = await axios.get(\r\n              \"https://messagesapp1.herokuapp.com/api/logIn/\" +\r\n                selectedConversation.Participants[0].id,\r\n              config\r\n            );\r\n            setCurrentConversationIsConnected(response.data.LastSeen);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    fetchData();\r\n  }, [ConnectedUsers, selectedConversation]);\r\n\r\n  //on first render,and every time conversation updates, get new conversations from DB\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      getConversations().then((res) => setConversations(res));\r\n    }\r\n\r\n    if (renderFlag) {\r\n      fetchData();\r\n      setRenderFlag(false);\r\n    }\r\n  }, [renderFlag]);\r\n\r\n  //when other user is typing, and this user is on this conversation, let him know other user is typing\r\n  useEffect(() => {\r\n    if (socket.current == null) return;\r\n    socket.current.on(\"user-typing\", ({ user, conversationId }) => {\r\n      if (selectedConversation) {\r\n        if (selectedConversation._id === conversationId) {\r\n          setTypingFlag(user.name);\r\n        }\r\n      }\r\n    });\r\n  }, [selectedConversation]);\r\n\r\n  //get updated conversations from DB when needed\r\n  async function getConversations() {\r\n    try {\r\n      let response = await axios.get(\r\n        \"https://messagesapp1.herokuapp.com/api/conversations/UserConversations/\" +\r\n          sessionStorage[\"id\"],\r\n        config\r\n      );\r\n      let ConversationsList = response.data.map((conversation) => {\r\n        let UpdatedConversation = conversation;\r\n\r\n        /*if this is a private conversation, and the name and picture saved as this user name, \r\n        update the conversation to other user name and picture*/\r\n        if (\r\n          !conversation.isGroup &&\r\n          conversation.Name === sessionStorage[\"name\"]\r\n        )\r\n          UpdatedConversation = {\r\n            ...UpdatedConversation,\r\n            Name: conversation.Participants[0].name,\r\n            ConversationImage: conversation.Participants[0].imageName,\r\n          };\r\n\r\n        //update the current shown on screen conversation\r\n        if (selectedConversation) {\r\n          if (selectedConversation._id === UpdatedConversation._id)\r\n            setSelectedConversation(UpdatedConversation);\r\n        }\r\n\r\n        return UpdatedConversation;\r\n      });\r\n\r\n      return ConversationsList;\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  }\r\n\r\n  //on search event, update shown conversations list\r\n  async function getSearchConverastions(str) {\r\n    getConversations().then((res) => {\r\n      let SearchResult = res.filter(\r\n        (conversation) => conversation.Name.includes(str) === true\r\n      );\r\n      setConversations(SearchResult);\r\n    });\r\n  }\r\n\r\n  //create new conversation\r\n  async function createConversation(ids, name, image, groupFlag) {\r\n    let ConversationImage = image;\r\n    let isGroup = groupFlag;\r\n    let messages = [];\r\n    let lastMessage = \"\";\r\n\r\n    //no participants chosen\r\n    if (ids.length === 0) {\r\n      return { status: \"error\", message: \"no participants choosen\" };\r\n    }\r\n\r\n    //check if conversation already exists and it's not a group.\r\n    let ConversationExists = null;\r\n    if (ids.length === 1 && !isGroup) {\r\n      ConversationExists = conversations.find(\r\n        (conversation) => conversation.Name === name\r\n      );\r\n    }\r\n\r\n    //if already exists, show the existing one\r\n    if (ConversationExists) setSelectedConversation(ConversationExists);\r\n    //create new conversation\r\n    else {\r\n      //get conversation participants\r\n      const participants = ids.map((id) => {\r\n        let addContactToConversation = contacts.filter(\r\n          (contact) => id === contact.id\r\n        );\r\n        return addContactToConversation[0];\r\n      });\r\n\r\n      //add creator to participants\r\n      participants.push({\r\n        id: info.id,\r\n        name: info.name,\r\n        phone: info.phone,\r\n        imageName: info.imageName,\r\n        LastSeen: info.LastSeen,\r\n      });\r\n\r\n      let createdDate = \"\";\r\n\r\n      //if group add creation date,add creation message and upload group picture\r\n      if (isGroup) {\r\n        let parts = new Intl.DateTimeFormat(\"en\", {\r\n          hc: \"h12\",\r\n          year: \"numeric\",\r\n          month: \"2-digit\",\r\n          day: \"2-digit\",\r\n          hour: \"numeric\",\r\n          minute: \"numeric\",\r\n          timeZone: \"Asia/Jerusalem\",\r\n        })\r\n          .formatToParts(new Date())\r\n          .reduce((acc, part) => {\r\n            acc[part.type] = part.value;\r\n            return acc;\r\n          }, Object.create(null));\r\n\r\n        createdDate = `${parts.day}/${parts.month}/${parts.year} ${parts.hour}:${parts.minute}`;\r\n\r\n        lastMessage = {\r\n          name: \"manager\",\r\n          message: info.name + \" created this group\",\r\n          timeSent: \"\",\r\n          containsImage: false,\r\n          containsRecord: false,\r\n          recordURL: null,\r\n        };\r\n        messages.push(lastMessage);\r\n\r\n        const data = new FormData();\r\n        data.append(\"file\", ConversationImage);\r\n        data.append(\"upload_preset\", \"whatsApp_clone\");\r\n        data.append(\"cloud_name\", \"dsrgpqnyv\");\r\n        try {\r\n          let response = await axios.post(\r\n            \"https://api.cloudinary.com/v1_1/dsrgpqnyv/image/upload\",\r\n            data\r\n          );\r\n          ConversationImage = response.data.url;\r\n        } catch (err) {\r\n          console.log(err);\r\n        }\r\n      }\r\n\r\n      let newConversation = {\r\n        Name: name,\r\n        creatorId: sessionStorage[\"id\"],\r\n        Participants: participants,\r\n        Messages: messages,\r\n        LastMessage: lastMessage,\r\n        ConversationImage: ConversationImage,\r\n        isGroup: isGroup,\r\n        createdDate: createdDate,\r\n        description: \"Add Description\",\r\n      };\r\n\r\n      //updateDB\r\n      try {\r\n        let Response = await axios.post(\r\n          \"https://messagesapp1.herokuapp.com/api/conversations\",\r\n          newConversation,\r\n          config\r\n        );\r\n\r\n        if (Response.data.status === \"created\") {\r\n          setSelectedConversation(Response.data.conversation);\r\n\r\n          //show conversation only if messages sent or if its A group\r\n          if (\r\n            Response.data.conversation.Messages.length > 0 ||\r\n            Response.data.conversation.isGroup === true\r\n          ) {\r\n            setConversations((prevConversations) => {\r\n              return [...prevConversations, Response.data.conversation];\r\n            });\r\n            socket.current.emit(\r\n              \"conversation-changed\",\r\n              Response.data.conversation\r\n            );\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.log(err);\r\n      }\r\n    }\r\n  }\r\n\r\n  //update existing conversation details when changed\r\n  async function UpdateConversation(updatedConversation) {\r\n    let updateDBConv = { ...updatedConversation };\r\n\r\n    //if user left the group, dont add him to DB\r\n    if (!updatedConversation.LastMessage.message.includes(\"left\")) {\r\n      let addCurrentParticipant = {\r\n        id: info.id,\r\n        phone: info.phone,\r\n        name: info.name,\r\n        imageName: info.imageName,\r\n        Status: info.Status,\r\n        color: info.color,\r\n      };\r\n      let participants = [\r\n        ...updatedConversation.Participants,\r\n        addCurrentParticipant,\r\n      ];\r\n      updateDBConv = { ...updateDBConv, Participants: participants };\r\n    }\r\n\r\n    delete updateDBConv._id;\r\n\r\n    try {\r\n      let response = await axios.put(\r\n        \"https://messagesapp1.herokuapp.com/api/conversations/\" +\r\n          selectedConversation._id,\r\n        updateDBConv,\r\n        config\r\n      );\r\n      if (response.data.status === \"Updated\") {\r\n        let UpdatedConversations = [];\r\n        if (!updatedConversation.LastMessage.message.includes(\"left\")) {\r\n          setSelectedConversation(updatedConversation);\r\n          conversations.forEach((conversation) => {\r\n            if (conversation._id === updatedConversation._id)\r\n              UpdatedConversations.push(updatedConversation);\r\n            else UpdatedConversations.push(conversation);\r\n          });\r\n        } else {\r\n          UpdatedConversations = conversations.filter(\r\n            (conversation) => conversation._id !== selectedConversation._id\r\n          );\r\n          setSelectedConversation();\r\n        }\r\n\r\n        //if user where removed by admin, send to user deleted case, so server let him know he was deleted\r\n        if (updatedConversation.LastMessage.message.includes(\"removed\"))\r\n          socket.current.emit(\"user-deleted\", selectedConversation);\r\n        else socket.current.emit(\"conversation-changed\", selectedConversation);\r\n\r\n        setConversations(UpdatedConversations);\r\n      }\r\n    } catch (err) {\r\n      console.log(err);\r\n    }\r\n  }\r\n\r\n  function updateConversationParticipant(\r\n    userUpdatedInfo,\r\n    infoFlag,\r\n    information\r\n  ) {\r\n    let updateConv = [];\r\n    conversations.map(async (conversation) => {\r\n      let updateCon = \"\";\r\n\r\n      if (\r\n        conversation.Name === userUpdatedInfo.info &&\r\n        conversation.isGroup == false\r\n      ) {\r\n        if (infoFlag === \"name\") {\r\n          updateCon = { ...conversation, Name: information };\r\n        } else if (infoFlag == \"image\")\r\n          updateCon = { ...conversation, ConversationImage: information };\r\n      } else updateCon = { ...conversation };\r\n\r\n      updateConv.push(updateCon);\r\n\r\n      let newParticipants = [...conversation.Participants, userUpdatedInfo];\r\n      let tempCon = { ...updateCon, Participants: newParticipants };\r\n      delete tempCon._id;\r\n\r\n      try {\r\n        await axios.put(\r\n          \"https://messagesapp1.herokuapp.com/api/conversations/\" +\r\n            conversation._id,\r\n          tempCon,\r\n          config\r\n        );\r\n      } catch (err) {\r\n        console.log(err);\r\n      }\r\n\r\n      socket.current.emit(\"conversation-changed\", updateCon);\r\n      setConversations(updateConv);\r\n    });\r\n  }\r\n\r\n  //add message got from other user to conversation\r\n  const addMessageToConversation = useCallback(\r\n    async ({ UpdatedConv }) => {\r\n      //voice alert\r\n      audio.play();\r\n\r\n      let ConversationExists = false;\r\n\r\n      //use refConversations to void infinite loop\r\n      let newListOfConversations = RefConversations.current.map(\r\n        (conversation) => {\r\n          if (conversation._id === UpdatedConv._id) {\r\n            ConversationExists = true;\r\n            let newConv = {\r\n              ...conversation,\r\n              Messages: UpdatedConv.Messages,\r\n              LastMessage: UpdatedConv.LastMessage,\r\n            };\r\n            if (currentConversationRef.current) {\r\n              if (currentConversationRef.current._id === UpdatedConv._id)\r\n                setSelectedConversation(newConv);\r\n            }\r\n\r\n            return newConv;\r\n          } else return conversation;\r\n        }\r\n      );\r\n\r\n      // if this is a new conversation first message, update user conversations\r\n      if (!ConversationExists) {\r\n        if (!UpdatedConv.isGroup) {\r\n          let newConversation = {\r\n            ...UpdatedConv,\r\n            Name: UpdatedConv.Participants[0].name,\r\n            ConversationImage: UpdatedConv.Participants[0].imageName,\r\n          };\r\n\r\n          setConversations((prevConversations) => [\r\n            ...prevConversations,\r\n            newConversation,\r\n          ]);\r\n        } else\r\n          setConversations((prevConversations) => [\r\n            ...prevConversations,\r\n            UpdatedConv,\r\n          ]);\r\n      } else setConversations(newListOfConversations);\r\n    },\r\n    [setConversations]\r\n  );\r\n\r\n  //handle messages socket\r\n  useEffect(() => {\r\n    if (socket.current == null) return;\r\n\r\n    RefConversations.current = conversations;\r\n    currentConversationRef.current = selectedConversation;\r\n    socket.current.on(\"receive-message\", addMessageToConversation);\r\n\r\n    return () =>\r\n      socket.current.off(\"receive-message\", addMessageToConversation);\r\n  }, [conversations, selectedConversation]);\r\n\r\n  //update the message sender conversations\r\n  const updateSenderConversation = (AddMessage) => {\r\n    let ConversationExists = false;\r\n    setSelectedConversation(AddMessage);\r\n\r\n    let newListOfConcversations = conversations.map((conversation) => {\r\n      if (conversation._id === AddMessage._id) {\r\n        ConversationExists = true;\r\n        return AddMessage;\r\n      } else return conversation;\r\n    });\r\n\r\n    if (ConversationExists) {\r\n      setConversations(newListOfConcversations);\r\n    } else\r\n      setConversations((prevConversations) => [\r\n        ...prevConversations,\r\n        AddMessage,\r\n      ]);\r\n  };\r\n\r\n  //send new message to chat users\r\n  function sendMessage(text, imageFlag, imageURL, recordURL) {\r\n    let parts = new Intl.DateTimeFormat(\"en\", {\r\n      hc: \"h12\",\r\n      year: \"numeric\",\r\n      month: \"2-digit\",\r\n      day: \"2-digit\",\r\n      hour: \"numeric\",\r\n      minute: \"numeric\",\r\n      timeZone: \"Asia/Jerusalem\",\r\n    })\r\n      .formatToParts(new Date())\r\n      .reduce((acc, part) => {\r\n        acc[part.type] = part.value;\r\n        return acc;\r\n      }, Object.create(null));\r\n\r\n    let time = `${parts.day}/${parts.month}/${parts.year}  ${parts.hour}:${parts.minute}`;\r\n\r\n    let recordFlag = false;\r\n\r\n    if (recordURL != null) recordFlag = true;\r\n\r\n    let CurrentMessage = {\r\n      id: info.id,\r\n      name: info.name,\r\n      color: info.color,\r\n      message: text,\r\n      timeSent: time,\r\n      containsImage: imageFlag,\r\n      containsRecord: recordFlag,\r\n      recordURL: recordURL,\r\n    };\r\n    if (imageFlag === true)\r\n      CurrentMessage = { ...CurrentMessage, imageURL: imageURL };\r\n\r\n    let sender = {\r\n      id: info.id,\r\n      phone: info.phone,\r\n      name: info.name,\r\n      imageName: info.imageName,\r\n    };\r\n\r\n    let AddMessage = {\r\n      ...selectedConversation,\r\n      Messages: [...selectedConversation.Messages, CurrentMessage],\r\n      LastMessage: CurrentMessage,\r\n    };\r\n\r\n    socket.current.emit(\"send-message\", {\r\n      sender: sender,\r\n      UpdatedConversation: AddMessage,\r\n      conversationId: selectedConversation._id,\r\n    });\r\n\r\n    updateSenderConversation(AddMessage);\r\n  }\r\n\r\n  return (\r\n    <ConversationsContext.Provider\r\n      value={{\r\n        sendMessage,\r\n        conversations,\r\n        createConversation,\r\n        setConversations,\r\n        setSelectedConversation,\r\n        selectedConversation,\r\n        currentConversationIsConnected,\r\n        typingFlag,\r\n        setTypingFlag,\r\n        getSearchConverastions,\r\n        showDetails,\r\n        setShowDetails,\r\n        UpdateConversation,\r\n        removedFromGroupFlag,\r\n        setRemovedFromGroupFlag,\r\n        updateConversationParticipant,\r\n      }}\r\n    >\r\n      {children}\r\n    </ConversationsContext.Provider>\r\n  );\r\n}\r\n"]},"metadata":{},"sourceType":"module"}