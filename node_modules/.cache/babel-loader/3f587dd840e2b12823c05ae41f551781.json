{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { useReducer } from 'react';\nconst initState = {\n  isRecording: false,\n  recorder: null,\n  data: null\n};\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'start':\n      return Object.assign(Object.assign({}, state), {\n        isRecording: true\n      });\n\n    case 'stop':\n      return Object.assign(Object.assign({}, state), {\n        isRecording: false\n      });\n\n    case 'startRecording':\n      return Object.assign(Object.assign({}, state), {\n        isRecording: true,\n        recorder: action.payload.recorder\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport const useVoiceRecorder = cb => {\n  const [state, dispatch] = useReducer(reducer, initState);\n\n  const finishRecording = ({\n    data\n  }) => {\n    cb(data);\n  };\n\n  const start = () => __awaiter(void 0, void 0, void 0, function* () {\n    dispatch({\n      type: 'start'\n    });\n    const stream = yield navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    const recorder = new MediaRecorder(stream);\n    dispatch({\n      type: 'startRecording',\n      payload: {\n        recorder\n      }\n    });\n    recorder.start();\n    recorder.addEventListener('dataavailable', finishRecording);\n  });\n\n  const stop = () => {\n    const recorder = state.recorder;\n    dispatch({\n      type: 'stop'\n    });\n\n    if (recorder) {\n      recorder.stop();\n      recorder.removeEventListener('dataavailable', finishRecording);\n    }\n  };\n\n  return {\n    start,\n    stop,\n    recorder: state.recorder,\n    isRecording: state.isRecording\n  };\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,UAAT,QAA2B,OAA3B;AAoBA,MAAM,SAAS,GAAU;AACvB,EAAA,WAAW,EAAE,KADU;AAEvB,EAAA,QAAQ,EAAE,IAFa;AAGvB,EAAA,IAAI,EAAE;AAHiB,CAAzB;;AAMA,MAAM,OAAO,GAAG,CAAC,KAAD,EAAe,MAAf,KAAyC;AACvD,UAAQ,MAAM,CAAC,IAAf;AACE,SAAK,OAAL;AACE,aAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAW,KAAX,CAAA,EAAgB;AAAE,QAAA,WAAW,EAAE;AAAf,OAAhB,CAAA;;AACF,SAAK,MAAL;AACE,aAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAW,KAAX,CAAA,EAAgB;AAAE,QAAA,WAAW,EAAE;AAAf,OAAhB,CAAA;;AACF,SAAK,gBAAL;AACE,aAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAW,KAAX,CAAA,EAAgB;AAAE,QAAA,WAAW,EAAE,IAAf;AAAqB,QAAA,QAAQ,EAAE,MAAM,CAAC,OAAP,CAAe;AAA9C,OAAhB,CAAA;;AACF;AACE,aAAO,KAAP;AARJ;AAUD,CAXD;;AAaA,OAAO,MAAM,gBAAgB,GAAI,EAAD,IAA4C;AAC1E,QAAM,CAAC,KAAD,EAAQ,QAAR,IAAoB,UAAU,CAAC,OAAD,EAAU,SAAV,CAApC;;AAEA,QAAM,eAAe,GAAG,CAAC;AAAC,IAAA;AAAD,GAAD,KAAyB;AAAG,IAAA,EAAE,CAAC,IAAD,CAAF;AAAW,GAA/D;;AAEA,QAAM,KAAK,GAAG,MAAW,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACvB,IAAA,QAAQ,CAAC;AAAC,MAAA,IAAI,EAAE;AAAP,KAAD,CAAR;AACA,UAAM,MAAM,GAAG,MAAM,SAAS,CAAC,YAAV,CAAuB,YAAvB,CAAoC;AAAC,MAAA,KAAK,EAAE;AAAR,KAApC,CAArB;AACA,UAAM,QAAQ,GAAG,IAAI,aAAJ,CAAkB,MAAlB,CAAjB;AACA,IAAA,QAAQ,CAAC;AAAC,MAAA,IAAI,EAAE,gBAAP;AAAyB,MAAA,OAAO,EAAE;AAAC,QAAA;AAAD;AAAlC,KAAD,CAAR;AACA,IAAA,QAAQ,CAAC,KAAT;AACA,IAAA,QAAQ,CAAC,gBAAT,CAA0B,eAA1B,EAA2C,eAA3C;AACD,GAPwB,CAAzB;;AASA,QAAM,IAAI,GAAG,MAAK;AAChB,UAAM,QAAQ,GAAG,KAAK,CAAC,QAAvB;AACA,IAAA,QAAQ,CAAC;AAAC,MAAA,IAAI,EAAE;AAAP,KAAD,CAAR;;AACA,QAAI,QAAJ,EAAc;AACZ,MAAA,QAAQ,CAAC,IAAT;AACA,MAAA,QAAQ,CAAC,mBAAT,CAA6B,eAA7B,EAA8C,eAA9C;AACD;AACF,GAPD;;AASA,SAAO;AACL,IAAA,KADK;AAEL,IAAA,IAFK;AAGL,IAAA,QAAQ,EAAE,KAAK,CAAC,QAHX;AAIL,IAAA,WAAW,EAAE,KAAK,CAAC;AAJd,GAAP;AAMD,CA7BM","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useReducer } from 'react';\nconst initState = {\n    isRecording: false,\n    recorder: null,\n    data: null\n};\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'start':\n            return Object.assign(Object.assign({}, state), { isRecording: true });\n        case 'stop':\n            return Object.assign(Object.assign({}, state), { isRecording: false });\n        case 'startRecording':\n            return Object.assign(Object.assign({}, state), { isRecording: true, recorder: action.payload.recorder });\n        default:\n            return state;\n    }\n};\nexport const useVoiceRecorder = (cb) => {\n    const [state, dispatch] = useReducer(reducer, initState);\n    const finishRecording = ({ data }) => { cb(data); };\n    const start = () => __awaiter(void 0, void 0, void 0, function* () {\n        dispatch({ type: 'start' });\n        const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });\n        const recorder = new MediaRecorder(stream);\n        dispatch({ type: 'startRecording', payload: { recorder } });\n        recorder.start();\n        recorder.addEventListener('dataavailable', finishRecording);\n    });\n    const stop = () => {\n        const recorder = state.recorder;\n        dispatch({ type: 'stop' });\n        if (recorder) {\n            recorder.stop();\n            recorder.removeEventListener('dataavailable', finishRecording);\n        }\n    };\n    return {\n        start,\n        stop,\n        recorder: state.recorder,\n        isRecording: state.isRecording,\n    };\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}